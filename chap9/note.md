
# 第九章

## 检测点9-1 (1)

要使用指令jmp word ptr [bx+1]后，指向第一条指令。首先需要明显第一条指令的地址是CS:0。因为转换指令使用的是word，故只需要修改IP寄存器。即[BX+1]地址开始的一个word单元内应该是0即可。

故最简单的是设置3个字节的0数据。

## 检测点9-1 (2)

要使用指令jmp dword ptr ds:[0]后， 指向第一条指令。 首先需要明显第一条指令的地址是CS:0。因为转换指令使用的是dword，故需要修改CS和IP。故应该向[bx]地址送入新的IP，[bx+2]地址送入新的CS。

以上两人个程序完成修改后，都成了死循环程序。一直循环。

## 实验8

此实验的核心点在于理解短跳转指令。

```asm
code_seg segment
    mov ax, 4c00h
    int 21h
start:
    mov ax, 0
s:  nop
    nop
    mov di, offset s
    mov si, offset s2
    mov ax, cs:[si]
    mov cs:[di], ax
s0: jmp short s
s1: mov ax, 0
    int 21h
    mov ax, 0
s2: jmp short s1
    nop
code_seg ends
end start
```

通过di, si将s2处的两字节jmp指令复制到s处覆盖两条nop指令。从表面看，程序执行时，从s0处跳转到s处后，根据刚才复制的指令，又跳转到s1处，故从s1处下条指令int 21h退出。

但实际的跳转内容，需要确定清楚复制的两字节到底是什么内容，及jmp短跳转的本质。即短跳转不带目的地址，而是带一字节的偏移以实现-128~127范围内的跳转。

```asm
s1: mov ax, 0       ; B80000
    int 21h         ; CD21
    mov ax, 0       ; B80000
s2: jmp short s1    ; EBF6
```

这段跳转指令偏移是s2 - s1的字节数，即2条mov和1条int指令的字节数。故nop被覆盖后，当执行s处时，偏移量也是2条mov和1条int指令的字节数。则正好是 mov ax, 4c00h指令。故可以正常退出。

最直观的办法是在debug时观察jmp的实际代码是EBF6, F6是负数，11110110b，取反1001加1得负数1010，即-10。当取完指令执行jmp前，IP已经加2，故-10实际是从当前指令向后跳转8字节。即2条mov和1条int指令的字节数。


## 实验9　显示字符串

本次要显示字符串，使用DS:SI，ES:DI分别做源和目的地址。DI每次循环前都要先压栈以备下次累加为新的一行首字符地址。

因为要重复三次，使用CX即做外层循环输出每行，又做内部循环输出行内的字符。故进入内循环前要压栈CX。

另外又将每次要显示的属性值也写在数据段里，使用BX来指示。其他直接读代码和注释。

